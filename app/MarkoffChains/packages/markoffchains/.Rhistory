theta_new[2] <- sum(K[i] * gamma_i_c[,2])/(n*sum(gamma_i_c[,2]))
theta_new[3] <- sum(gamma_i_c[,1])/N
return(rbind(theta, theta_new))
}
eps <- 1e-2
theta0 <- rnorm(3, 0.5, 0.1)
theta <- t(as.matrix(theta0, 1,3))
theta
j <- 1
while( j ==1 || norm( as.matrix(theta[j,] - theta[j-1, ]) ) > eps ) {
theta <- EM_iteration(j, theta)
j = j+1
}
print(theta)
######## the expectation maximisation algorithm
######## i can do tihs
N <- 30 # no of observations
K <- numeric(N)
n <- 10 # no. of tosses in each observation
# shh
Z <- numeric(N)
theta <- c(0.2, 0.8, 0.4)
for(i in 1:length(K)){
Z[i] <- sample.int(2, 1, T, c(theta[3], 1- theta[3]))
K[i] <- rbinom( 1, n, theta[Z[i]] )
}
####
K
gamma_i_c_j <- function( i, c, j){
if(c == 1) p <- theta[j, 3]
else p <- 1 - theta[j,3]
ans <- p * dbinom(K[i], n, theta[j,c]) / (theta[j, 3] * dbinom(K[i], n,theta[j,c]) +  (1-theta[j,3]) * dbinom(K[i], n, theta[j,3-c]) )
return(ans)
}
EM_iteration <- function(j, theta){
gamma_i_c <- matrix(0, N,2)
for(i in 1:N){
gamma_i_c[i, 1] <- gamma_i_c_j(i, 1, j)
gamma_i_c[i, 2] <- gamma_i_c_j(i, 2, j)
}
theta_new <- numeric(3)
theta_new[1] <- sum(K[i] * gamma_i_c[,1])/(n*sum(gamma_i_c[,1]))
theta_new[2] <- sum(K[i] * gamma_i_c[,2])/(n*sum(gamma_i_c[,2]))
theta_new[3] <- sum(gamma_i_c[,1])/N
return(rbind(theta, theta_new))
}
eps <- 1e-2
theta0 <- rnorm(3, 0.5, 0.1)
theta <- t(as.matrix(theta0, 1,3))
theta
j <- 1
while( j ==1 || norm( as.matrix(theta[j,] - theta[j-1, ]) ) > eps ) {
theta <- EM_iteration(j, theta)
j = j+1
}
print(theta)
######## the expectation maximisation algorithm
######## i can do tihs
N <- 30 # no of observations
K <- numeric(N)
n <- 10 # no. of tosses in each observation
# shh
Z <- numeric(N)
theta <- c(0.2, 0.8, 0.4)
for(i in 1:length(K)){
Z[i] <- sample.int(2, 1, T, c(theta[3], 1- theta[3]))
K[i] <- rbinom( 1, n, theta[Z[i]] )
}
####
K
gamma_i_c_j <- function( i, c, j){
if(c == 1) p <- theta[j, 3]
else p <- 1 - theta[j,3]
ans <- p * dbinom(K[i], n, theta[j,c]) / (theta[j, 3] * dbinom(K[i], n,theta[j,c]) +  (1-theta[j,3]) * dbinom(K[i], n, theta[j,3-c]) )
return(ans)
}
EM_iteration <- function(j, theta){
gamma_i_c <- matrix(0, N,2)
for(i in 1:N){
gamma_i_c[i, 1] <- gamma_i_c_j(i, 1, j)
gamma_i_c[i, 2] <- gamma_i_c_j(i, 2, j)
}
theta_new <- numeric(3)
theta_new[1] <- sum(K[i] * gamma_i_c[,1])/(n*sum(gamma_i_c[,1]))
theta_new[2] <- sum(K[i] * gamma_i_c[,2])/(n*sum(gamma_i_c[,2]))
theta_new[3] <- sum(gamma_i_c[,1])/N
return(rbind(theta, theta_new))
}
eps <- 1e-2
theta0 <- rnorm(3, 0.5, 0.1)
theta <- t(as.matrix(theta0, 1,3))
theta
j <- 1
while( j ==1 || norm( as.matrix(theta[j,] - theta[j-1, ]) ) > eps ) {
theta <- EM_iteration(j, theta)
j = j+1
}
print(theta)
######## the expectation maximisation algorithm
######## i can do tihs
N <- 30 # no of observations
K <- numeric(N)
n <- 10 # no. of tosses in each observation
# shh
Z <- numeric(N)
theta <- c(0.2, 0.8, 0.4)
for(i in 1:length(K)){
Z[i] <- sample.int(2, 1, T, c(theta[3], 1- theta[3]))
K[i] <- rbinom( 1, n, theta[Z[i]] )
}
####
K
gamma_i_c_j <- function( i, c, j){
if(c == 1) p <- theta[j, 3]
else p <- 1 - theta[j,3]
ans <- p * dbinom(K[i], n, theta[j,c]) / (theta[j, 3] * dbinom(K[i], n,theta[j,c]) +  (1-theta[j,3]) * dbinom(K[i], n, theta[j,3-c]) )
return(ans)
}
EM_iteration <- function(j, theta){
gamma_i_c <- matrix(0, N,2)
for(i in 1:N){
gamma_i_c[i, 1] <- gamma_i_c_j(i, 1, j)
gamma_i_c[i, 2] <- gamma_i_c_j(i, 2, j)
}
theta_new <- numeric(3)
theta_new[1] <- sum(K[i] * gamma_i_c[,1])/(n*sum(gamma_i_c[,1]))
theta_new[2] <- sum(K[i] * gamma_i_c[,2])/(n*sum(gamma_i_c[,2]))
theta_new[3] <- sum(gamma_i_c[,1])/N
return(rbind(theta, theta_new))
}
eps <- 1e-2
theta0 <- rnorm(3, 0.5, 0.1)
theta <- t(as.matrix(theta0, 1,3))
theta
j <- 1
while( j ==1 || norm( as.matrix(theta[j,] - theta[j-1, ]) ) > eps ) {
theta <- EM_iteration(j, theta)
j = j+1
}
print(theta)
######## the expectation maximisation algorithm
######## i can do tihs
N <- 30 # no of observations
K <- numeric(N)
n <- 10 # no. of tosses in each observation
# shh
Z <- numeric(N)
theta <- c(0.2, 0.8, 0.4)
for(i in 1:length(K)){
Z[i] <- sample.int(2, 1, T, c(theta[3], 1- theta[3]))
K[i] <- rbinom( 1, n, theta[Z[i]] )
}
####
K
gamma_i_c_j <- function( i, c, j){
if(c == 1) p <- theta[j, 3]
else p <- 1 - theta[j,3]
ans <- p * dbinom(K[i], n, theta[j,c]) / (theta[j, 3] * dbinom(K[i], n,theta[j,c]) +  (1-theta[j,3]) * dbinom(K[i], n, theta[j,3-c]) )
return(ans)
}
EM_iteration <- function(j, theta){
gamma_i_c <- matrix(0, N,2)
for(i in 1:N){
gamma_i_c[i, 1] <- gamma_i_c_j(i, 1, j)
gamma_i_c[i, 2] <- gamma_i_c_j(i, 2, j)
}
theta_new <- numeric(3)
theta_new[1] <- sum(K[i] * gamma_i_c[,1])/(n*sum(gamma_i_c[,1]))
theta_new[2] <- sum(K[i] * gamma_i_c[,2])/(n*sum(gamma_i_c[,2]))
theta_new[3] <- sum(gamma_i_c[,1])/N
return(rbind(theta, theta_new))
}
eps <- 1e-2
theta0 <- rnorm(3, 0.5, 0.1)
theta <- t(as.matrix(theta0, 1,3))
theta
j <- 1
while( j ==1 || norm( as.matrix(theta[j,] - theta[j-1, ]) ) > eps ) {
theta <- EM_iteration(j, theta)
j = j+1
}
print(theta)
######## the expectation maximisation algorithm
######## i can do tihs
N <- 30 # no of observations
K <- numeric(N)
n <- 10 # no. of tosses in each observation
# shh
Z <- numeric(N)
theta <- c(0.2, 0.8, 0.4)
for(i in 1:length(K)){
Z[i] <- sample.int(2, 1, T, c(theta[3], 1- theta[3]))
K[i] <- rbinom( 1, n, theta[Z[i]] )
}
####
K
gamma_i_c_j <- function( i, c, j){
if(c == 1) p <- theta[j, 3]
else p <- 1 - theta[j,3]
ans <- p * dbinom(K[i], n, theta[j,c]) / (theta[j, 3] * dbinom(K[i], n,theta[j,c]) +  (1-theta[j,3]) * dbinom(K[i], n, theta[j,3-c]) )
return(ans)
}
EM_iteration <- function(j, theta){
gamma_i_c <- matrix(0, N,2)
for(i in 1:N){
gamma_i_c[i, 1] <- gamma_i_c_j(i, 1, j)
gamma_i_c[i, 2] <- gamma_i_c_j(i, 2, j)
}
theta_new <- numeric(3)
theta_new[1] <- sum(K[i] * gamma_i_c[,1])/(n*sum(gamma_i_c[,1]))
theta_new[2] <- sum(K[i] * gamma_i_c[,2])/(n*sum(gamma_i_c[,2]))
theta_new[3] <- sum(gamma_i_c[,1])/N
return(rbind(theta, theta_new))
}
eps <- 1e-2
theta0 <- rnorm(3, 0.5, 0.1)
theta <- t(as.matrix(theta0, 1,3))
theta
j <- 1
while( j ==1 || norm( as.matrix(theta[j,] - theta[j-1, ]) ) > eps ) {
theta <- EM_iteration(j, theta)
j = j+1
}
print(theta)
gamma_i_c_j[1,1,1]
gamma_i_c_j(1,1,1)
gamma_i_c_j(1,2,1)
gamma_i_c_j <- function( i, c, j){
if(c == 1) p <- theta[j, 3]
else p <- 1 - theta[j,3]
ans <- p * dbinom(K[i], n, theta[j,c]) / (theta[j, 3] * dbinom(K[i], n,theta[j,1]) +  (1-theta[j,3]) * dbinom(K[i], n, theta[j,2]) )
return(ans)
}
gamma_i_c_j(1,1,1)
gamma_i_c_j(1,2,1)
######## the expectation maximisation algorithm
######## i can do tihs
N <- 30 # no of observations
K <- numeric(N)
n <- 10 # no. of tosses in each observation
# shh
Z <- numeric(N)
theta <- c(0.2, 0.8, 0.4)
for(i in 1:length(K)){
Z[i] <- sample.int(2, 1, T, c(theta[3], 1- theta[3]))
K[i] <- rbinom( 1, n, theta[Z[i]] )
}
####
K
gamma_i_c_j <- function( i, c, j){
if(c == 1) p <- theta[j, 3]
else p <- 1 - theta[j,3]
ans <- p * dbinom(K[i], n, theta[j,c]) / (theta[j, 3] * dbinom(K[i], n,theta[j,1]) +  (1-theta[j,3]) * dbinom(K[i], n, theta[j,2]) )
return(ans)
}
EM_iteration <- function(j, theta){
gamma_i_c <- matrix(0, N,2)
for(i in 1:N){
gamma_i_c[i, 1] <- gamma_i_c_j(i, 1, j)
gamma_i_c[i, 2] <- gamma_i_c_j(i, 2, j)
}
theta_new <- numeric(3)
theta_new[1] <- sum(K[i] * gamma_i_c[,1])/(n*sum(gamma_i_c[,1]))
theta_new[2] <- sum(K[i] * gamma_i_c[,2])/(n*sum(gamma_i_c[,2]))
theta_new[3] <- sum(gamma_i_c[,1])/N
return(rbind(theta, theta_new))
}
eps <- 1e-2
theta0 <- rnorm(3, 0.5, 0.1)
theta <- t(as.matrix(theta0, 1,3))
theta
j <- 1
while( j ==1 || norm( as.matrix(theta[j,] - theta[j-1, ]) ) > eps ) {
theta <- EM_iteration(j, theta)
j = j+1
}
warnings()
print(theta)
gamma_i_c_j(1,2,1)
gamma_i_c_j(1,1,1)
gamma_i_c_j(2,1,1)
gamma_i_c_j(2,1,1)
gamma_i_c_j(2,2x,1)
gamma_i_c_j(2,2,1)
gamma_i_c_j(2,2,2)
######## the expectation maximisation algorithm
######## i can do tihs
N <- 30 # no of observations
K <- numeric(N)
n <- 10 # no. of tosses in each observation
# shh
Z <- numeric(N)
theta <- c(0.2, 0.8, 0.4)
for(i in 1:length(K)){
Z[i] <- sample.int(2, 1, T, c(theta[3], 1- theta[3]))
K[i] <- rbinom( 1, n, theta[Z[i]] )
}
####
gamma_i_c_j <- function( i, c, j){
if(c == 1) p <- theta[j, 3]
else p <- 1 - theta[j,3]
ans <- p * dbinom(K[i], n, theta[j,c]) / (theta[j, 3] * dbinom(K[i], n,theta[j,1]) +  (1-theta[j,3]) * dbinom(K[i], n, theta[j,2]) )
return(ans)
}
EM_iteration <- function(j, theta){
gamma_i_c <- matrix(0, N,2)
for(i in 1:N){
gamma_i_c[i, 1] <- gamma_i_c_j(i, 1, j)
gamma_i_c[i, 2] <- gamma_i_c_j(i, 2, j)
}
theta_new <- numeric(3)
theta_new[1] <- sum(K[i] * gamma_i_c[,1])/(n*sum(gamma_i_c[,1]))
theta_new[2] <- sum(K[i] * gamma_i_c[,2])/(n*sum(gamma_i_c[,2]))
theta_new[3] <- sum(gamma_i_c[,1])/N
return(rbind(theta, theta_new))
}
eps <- 1e-2
theta0 <- rnorm(3, 0.5, 0.1)
theta <- t(as.matrix(theta0, 1,3))
theta
j <- 1
while( j ==1 || norm( as.matrix(theta[j,] - theta[j-1, ]) ) > eps ) {
theta <- EM_iteration(j, theta)
j = j+1
}
print(theta)
######## the expectation maximisation algorithm
######## i can do tihs
N <- 30 # no of observations
K <- numeric(N)
n <- 10 # no. of tosses in each observation
# shh
Z <- numeric(N)
theta <- c(0.2, 0.8, 0.4)
for(i in 1:length(K)){
Z[i] <- sample.int(2, 1, T, c(theta[3], 1- theta[3]))
K[i] <- rbinom( 1, n, theta[Z[i]] )
}
####
gamma_i_c_j <- function( i, c, j){
if(c == 1) p <- theta[j, 3]
else p <- 1 - theta[j,3]
ans <- p * dbinom(K[i], n, theta[j,c]) / (theta[j, 3] * dbinom(K[i], n,theta[j,1]) +  (1-theta[j,3]) * dbinom(K[i], n, theta[j,2]) )
return(ans)
}
EM_iteration <- function(j, theta){
gamma_i_c <- matrix(0, N,2)
for(i in 1:N){
gamma_i_c[i, 1] <- gamma_i_c_j(i, 1, j)
gamma_i_c[i, 2] <- gamma_i_c_j(i, 2, j)
}
theta_new <- numeric(3)
theta_new[1] <- sum(K[i] * gamma_i_c[,1])/(n*sum(gamma_i_c[,1]))
theta_new[2] <- sum(K[i] * gamma_i_c[,2])/(n*sum(gamma_i_c[,2]))
theta_new[3] <- sum(gamma_i_c[,1])/N
return(rbind(theta, theta_new))
}
eps <- 1e-2
theta0 <- rnorm(3, 0.5, 0.1)
theta <- t(as.matrix(theta0, 1,3))
theta
j <- 1
while( j ==1 || norm( as.matrix(theta[j,] - theta[j-1, ]) ) > eps ) {
theta <- EM_iteration(j, theta)
j = j+1
}
######## the expectation maximisation algorithm
######## i can do tihs
N <- 30 # no of observations
K <- numeric(N)
n <- 10 # no. of tosses in each observation
# shh
Z <- numeric(N)
theta <- c(0.2, 0.8, 0.4)
for(i in 1:length(K)){
Z[i] <- sample.int(2, 1, T, c(theta[3], 1- theta[3]))
K[i] <- rbinom( 1, n, theta[Z[i]] )
}
####
gamma_i_c_j <- function( i, c, j){
if(c == 1) p <- theta[j, 3]
else p <- 1 - theta[j,3]
ans <- p * dbinom(K[i], n, theta[j,c]) / (theta[j, 3] * dbinom(K[i], n,theta[j,1]) +  (1-theta[j,3]) * dbinom(K[i], n, theta[j,2]) )
return(ans)
}
EM_iteration <- function(j, theta){
gamma_i_c <- matrix(0, N,2)
for(i in 1:N){
gamma_i_c[i, 1] <- gamma_i_c_j(i, 1, j)
gamma_i_c[i, 2] <- gamma_i_c_j(i, 2, j)
}
theta_new <- numeric(3)
theta_new[1] <- sum(K[i] * gamma_i_c[,1])/(n*sum(gamma_i_c[,1]))
theta_new[2] <- sum(K[i] * gamma_i_c[,2])/(n*sum(gamma_i_c[,2]))
theta_new[3] <- sum(gamma_i_c[,1])/N
return(rbind(theta, theta_new))
}
eps <- 1e-2
theta0 <- rnorm(3, 0.5, 0.1)
theta <- t(as.matrix(theta0, 1,3))
theta
j <- 1
while( j ==1 || norm( as.matrix(theta[j,] - theta[j-1, ]) ) > eps ) {
theta <- EM_iteration(j, theta)
j = j+1
}
print(theta)
N <- 30 # no of observations
K <- numeric(N)
n <- 10 # no. of tosses in each observation
# shh
Z <- numeric(N)
theta <- c(0.2, 0.8, 0.4)
for(i in 1:length(K)){
Z[i] <- sample.int(2, 1, T, c(theta[3], 1- theta[3]))
K[i] <- rbinom( 1, n, theta[Z[i]] )
}
####
K
Z
sum(Z==1)
gamma_i_c_j <- function( i, c, j){
if(c == 1) p <- theta[j, 3]
else p <- 1 - theta[j,3]
ans <- p * dbinom(K[i], n, theta[j,c]) / (theta[j, 3] * dbinom(K[i], n,theta[j,1]) +  (1-theta[j,3]) * dbinom(K[i], n, theta[j,2]) )
return(ans)
}
theta0
theta0 <- c(0.2, 0.8, 0.4)
theta <- t(as.matrix(theta0, 1,3))
EM_iteration(1, theta)
N <- 300 # no of observations
K <- numeric(N)
n <- 20 # no. of tosses in each observation
# shh
Z <- numeric(N)
theta <- c(0.2, 0.8, 0.4)
for(i in 1:length(K)){
Z[i] <- sample.int(2, 1, T, c(theta[3], 1- theta[3]))
K[i] <- rbinom( 1, n, theta[Z[i]] )
}
####
K
Z
sum(Z==1)
sum(Z==2)
theta0 <- c(0.2, 0.8, 0.417)
theta <- t(as.matrix(theta0, 1,3))
EM_iteration(1, theta)
N <- 30 # no of observations
K <- numeric(N)
n <- 10 # no. of tosses in each observation
# shh
Z <- numeric(N)
theta <- c(0.2, 0.8, 0.4)
for(i in 1:length(K)){
Z[i] <- sample.int(2, 1, T, c(theta[3], 1- theta[3]))
K[i] <- rbinom( 1, n, theta[Z[i]] )
}
####
K
Z
sum(Z==2)
# import and inspect
Races<-read.table("http://stat4ds.rwth-aachen.de/data/ScotsRaces.dat", header=TRUE)
head(Races,3) # timeM for men, timeW for women
matrix(cbind(mean(Races$timeW),sd(Races$timeW),mean(Races$climb),sd(Races$climb),mean(Races$distance), sd(Races$distance)),nrow=2)
#visualise
pairs(~timeW+distance+climb, data=Races) #scatter plot matrix
cor(Races[,c("timeW","distance","climb")]) # correlation matrix
cor(Races[,c("timeW","distance","climb")]) # correlation matrix
cor(Races[-41,c("timeW","distance","climb")]) # correlation matrix
fit.d<-lm(timeW~distance,data=Races)# model E(timeW) as a linear function of distance
summary(fit.d)
LM.m_from_w = lm(timeM~ timeW, data = Races)
summary(LM.m_from_w)
Florida<-read.table("http://stat4ds.rwth-aachen.de/data/Florida.dat", header=TRUE)
setwd("~/projects/markov_chains_R/prototype_0.1/markoffchains")
document()
library(devtools)
library(roxygen2)
document()
rlang::last_trace()
source("/R/access.R")
source("R/access.R")
source("access.R")
?source
source("./R/access.R")
?cd
getwd()
"./"
?paste0
source("./R/access.R")
file.exists("./R/access.R")
source("./R/access.R")
file.exists("./R/access.R")
file.exists("./R/acces.R")
file.exists("./R/is_stochastic.R")
source("./R/is_stochastic.R")
document()
document()
document()
document()
document()
document()
document()
rm(list = c("access", "comm_classes", "is_stochastic"))
document()
use_mit_license()
document()
document()
cls()
